package com.varabyte.kotter.foundation.input

import com.varabyte.kotter.foundation.anim.Anim
import com.varabyte.kotter.foundation.text.*
import com.varabyte.kotter.foundation.timer.addTimer
import com.varabyte.kotter.runtime.*
import com.varabyte.kotter.runtime.concurrent.ConcurrentScopedData
import com.varabyte.kotter.runtime.concurrent.createKey
import com.varabyte.kotter.runtime.internal.ansi.Ansi
import com.varabyte.kotter.runtime.terminal.Terminal
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.time.Duration
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

// Once created, we keep it alive for the session, because Flow is designed to be collected multiple times, meaning
// there's no reason for us to keep recreating it. It's pretty likely that if a session uses input in one block, it
// will use input again in others. (We can always revisit this decision later and scope this to a Section lifecycle
// instead)
private val KeyFlowKey = Session.Lifecycle.createKey<Flow<Key>>()

/**
 * Create a [Flow<Key>] value which converts bytes read from a terminal into keys, handling some gnarly multi-byte
 * cases and smoothing over other inconsistent, historical legacy.
 */
private fun ConcurrentScopedData.prepareKeyFlow(terminal: Terminal) {
    tryPut(KeyFlowKey) {
        val keyLock = ReentrantLock()
        val escSeq = StringBuilder()
        var lastKeyTime: Long
        channelFlow {
            terminal.read().collect { byte ->
                val c = byte.toChar()
                val key = keyLock.withLock {
                    lastKeyTime = System.currentTimeMillis()
                    when {
                        escSeq.isNotEmpty() -> {
                            // Normally, we get here if we're continuing an existing esc sequence, but if so some reason
                            // a previous one was never consumed *and* we are starting a new ESC sequence, just clear
                            // out anything left over from before. This could happen for example if the user just
                            // pressed ESC (which puts an ESC in the escSeq queue and waits a while before sending it
                            // out), but maybe also we end up getting an escape sequence that we didn't know how to
                            // handle, and without doing this, that old sequence would block us from working ever again.
                            if (c == Ansi.CtrlChars.ESC) escSeq.clear()

                            escSeq.append(c)
                            val code = Ansi.EscSeq.toCsiCode(escSeq)
                            if (code != null) {
                                escSeq.clear()
                                when (code) {
                                    Ansi.Csi.Codes.Keys.UP -> Keys.UP
                                    Ansi.Csi.Codes.Keys.DOWN -> Keys.DOWN
                                    Ansi.Csi.Codes.Keys.LEFT -> Keys.LEFT
                                    Ansi.Csi.Codes.Keys.RIGHT -> Keys.RIGHT
                                    Ansi.Csi.Codes.Keys.HOME, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_START -> Keys.HOME
                                    Ansi.Csi.Codes.Keys.INSERT -> Keys.INSERT
                                    Ansi.Csi.Codes.Keys.DELETE -> Keys.DELETE
                                    Ansi.Csi.Codes.Keys.END, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_END -> Keys.END
                                    Ansi.Csi.Codes.Keys.PG_UP -> Keys.PAGE_UP
                                    Ansi.Csi.Codes.Keys.PG_DOWN -> Keys.PAGE_DOWN
                                    else -> null
                                }
                            } else {
                                null
                            }
                        }
                        else -> {
                            when (c) {
                                Ansi.CtrlChars.EOF -> Keys.EOF
                                // Windows uses BACKSPACE, *nix uses DELETE? Best to support both
                                Ansi.CtrlChars.BACKSPACE, Ansi.CtrlChars.DELETE -> Keys.BACKSPACE
                                Ansi.CtrlChars.TAB -> Keys.TAB
                                Ansi.CtrlChars.ENTER -> Keys.ENTER
                                Ansi.CtrlChars.ESC -> {
                                    escSeq.append(c)
                                    // This is kind of ugly but we need to detect the difference between the user pressing
                                    // ESC on their own vs it being the first character in a chain of an escape sequence
                                    // generated by the terminal. If the terminal generates an escape sequence, the whole
                                    // thing is consumed sub millisecond, so waiting a couple dozen ms to be sure we aren't
                                    // getting any followup characters. Note that a user can hold the keys down which
                                    // generates a bunch of key signals, so we additionally make sure there hasn't been
                                    // any other key pressed
                                    CoroutineScope(Dispatchers.IO).launch {
                                        val delayMs = 50L
                                        var doneWaiting = false
                                        var sendEsc = false
                                        while (!doneWaiting) {
                                            delay(10L)
                                            keyLock.withLock {
                                                if (System.currentTimeMillis() - lastKeyTime > delayMs) {
                                                    sendEsc = escSeq.length == 1 && escSeq.contains(Ansi.CtrlChars.ESC)
                                                    if (sendEsc) escSeq.clear()
                                                    doneWaiting = true
                                                }
                                            }
                                        }
                                        if (sendEsc) send(Keys.ESC)
                                    }
                                    null
                                }
                                else -> if (!c.isISOControl()) CharKey(c) else null
                            }
                        }
                    }
                }

                if (key != null) {
                    send(key)
                }
            }
        }
            // We only want to collect keypresses in one place per session. Use shareIn so collecters don't spawn new
            // flows. For example, multiple flows here would really mess with the escSeq logic
            .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Lazily)
    }
}



/** State needed to support the `input()` function */
private class InputState(val id: Any, val cursorState: BlinkingCursorState) {
    var isActive = false

    private var _text = ""
    private var _index = 0

    var text
        get() = _text
        set(value) {
            if (_text != value) {
                _text = value
                _index = _text.length
                if (isActive) cursorState.resetCursor()
            }
        }

    var index
        get() = _index
        set(value) {
            @Suppress("NAME_SHADOWING")
            val value = value.coerceAtMost(_text.length)
            if (_index != value) {
                _index = value
                if (isActive) cursorState.resetCursor()
            }
        }
}

private class BlinkingCursorState {
    companion object {
        private const val BLINKING_DURATION_MS = 500
    }

    var blinkOn = true
    var blinkElapsedMs = 0

    fun resetCursor() {
        blinkOn = true
        blinkElapsedMs = 0
    }

    /** Elapse the timer on this input state's cursor animation, returning true if the cursor actually changed. */
    fun elapse(duration: Duration): Boolean {
        val prevBlinkOn = blinkOn
        blinkElapsedMs += duration.toMillis().toInt()
        while (blinkElapsedMs > BLINKING_DURATION_MS) {
            blinkElapsedMs -= BLINKING_DURATION_MS
            blinkOn = !blinkOn
        }
        return prevBlinkOn != blinkOn
    }
}

private val InputStatesKey = Section.Lifecycle.createKey<MutableMap<Any, InputState>>()
private val BlinkingCursorStateKey = Section.Lifecycle.createKey<BlinkingCursorState>()
private val InputStatesCalledThisRender = MainRenderScope.Lifecycle.createKey<MutableMap<Any, InputState>>()
private val UpdateInputJobKey = Section.Lifecycle.createKey<Job>()


private fun ConcurrentScopedData.activate(state: InputState) {
    if (state.isActive) return
    get(InputActivatedCallbackKey) {
        val onInputActivatedScope = OnInputActivatedScope(state.id, state.text)
        this.invoke(onInputActivatedScope)
        state.text = onInputActivatedScope.input
    }
    state.isActive = true
}

private fun ConcurrentScopedData.deactivate(state: InputState) {
    if (!state.isActive) return
    get(InputDeactivatedCallbackKey) {
        val onInputDeactivatedScope = OnInputDeactivatedScope(state.id, state.text)
        this.invoke(onInputDeactivatedScope)
        state.text = onInputDeactivatedScope.input
    }
    state.isActive = false
}

/**
 * If necessary, instantiate data that the [input] method expects to exist.
 *
 * Is a no-op after the first time.
 */
private fun ConcurrentScopedData.prepareInput(scope: MainRenderScope, id: Any, initialText: String, isActive: Boolean) {
    val section = scope.section
    prepareKeyFlow(section.session.terminal)
    val cursorState = putOrGet(BlinkingCursorStateKey) {
        val cursorState = BlinkingCursorState()
        // This block represents global state that gets triggered just once for all input blocks in this section, so we
        // do some quick init side effects as well

        addTimer(Anim.ONE_FRAME_60FPS, repeat = true, key = cursorState) {
            if (cursorState.elapse(elapsed)) {
                section.requestRerender()
            }
        }

        section.onRendered {
            // We need to indirectly detect if a previously active input state was not called this frame. This can
            // happen either if we called OTHER input states this frame OR if we called NO input states this frame.
            // We can detect both of these cases by querying the "input states called this render" key.
            val idsRenderedThisFrame = mutableSetOf<Any>()
            remove(InputStatesCalledThisRender) {
                idsRenderedThisFrame.addAll(this.keys)
            }
            get(InputStatesKey) {
                val unrenderedActiveInputStates = this.values.filter { it.isActive && !idsRenderedThisFrame.contains(it.id) }
                if (unrenderedActiveInputStates.isNotEmpty()) {
                    unrenderedActiveInputStates.forEach { deactivate(it) }
                }
            }

            if (idsRenderedThisFrame.isEmpty()) {
                // A minor touch, but always make sure the cursor starts from scratch anytime a new input method is
                // called in the future
                cursorState.resetCursor()
            }
        }

        section.onFinishing {
            // If we are exiting the block but by chance the blinking cursor was on, turn it off!
            if (cursorState.blinkOn) {
                cursorState.resetCursor()
                section.requestRerender()
            }
        }

        cursorState
    }!!

    putIfAbsent(InputStatesKey, provideInitialValue = { mutableMapOf() }) {
        val inputStates = this
        val state = inputStates.computeIfAbsent(id) {
            val newState = InputState(id, cursorState)
            newState.text = initialText
            newState.index = initialText.length
            newState
        }

        putIfAbsent(InputStatesCalledThisRender, provideInitialValue = { mutableMapOf() }) {
            val renderedInputStates = this
            if (renderedInputStates.contains(id)) {
                throw IllegalArgumentException("Got more than one `input` in a single render pass with ID $id")
            }
            if (isActive && renderedInputStates.values.any { it.isActive }) {
                throw IllegalArgumentException("Having more than one active `input` in a single render pass is not supported")
            }
            renderedInputStates[id] = state
        }

        if (state.isActive != isActive) {
            if (isActive) {
                activate(state)
            } else {
                deactivate(state)
            }
        }
    }

    tryPut(
        UpdateInputJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    withActiveInput {
                        val prevText = text
                        val prevIndex = index
                        var proposedText: String? = null
                        var proposedIndex: Int? = null
                        when (key) {
                            Keys.LEFT -> index = (index - 1).coerceAtLeast(0)
                            Keys.RIGHT -> {
                                if (index < text.length) {
                                    index++
                                }
                                else {
                                    get(CompleterKey) {
                                        complete(text)?.let { completion ->
                                            val finalText = text + completion
                                            proposedText = finalText
                                            proposedIndex = finalText.length
                                        }
                                    }
                                }
                            }
                            Keys.HOME -> index = 0
                            Keys.END -> index = text.length
                            Keys.DELETE -> {
                                if (index <= text.lastIndex) {
                                    proposedText = text.removeRange(index, index + 1)
                                }
                            }

                            Keys.BACKSPACE -> {
                                if (index > 0) {
                                    proposedText = text.removeRange(index - 1, index)
                                    proposedIndex = index - 1
                                }
                            }

                            Keys.ENTER -> {
                                var rejected = false
                                var cleared = false
                                get(InputEnteredCallbackKey) {
                                    val onInputEnteredScope = OnInputEnteredScope(id, text)
                                    this.invoke(onInputEnteredScope)
                                    rejected = onInputEnteredScope.rejected
                                    cleared = onInputEnteredScope.cleared
                                }
                                if (!rejected) {
                                    get(SystemInputEnteredCallbackKey) { this.invoke() }
                                }
                                if (cleared) {
                                    getValue(InputStatesKey).remove(id)
                                }
                            }
                            else ->
                                if (key is CharKey) {
                                    proposedText = "${text.take(index)}${key.code}${text.takeLast(text.length - index)}"
                                    proposedIndex = index + 1
                                }
                        }

                        if (proposedText != null) {
                            get(InputChangedCallbackKey) {
                                val onInputChangedScope = OnInputChangedScope(id, input = proposedText!!, prevInput = text)
                                this.invoke(onInputChangedScope)

                                proposedText = if (!onInputChangedScope.rejected) onInputChangedScope.input else onInputChangedScope.prevInput
                            }

                            text = proposedText!!
                            index = (proposedIndex ?: index).coerceIn(0, text.length)
                        }

                        if (text != prevText || index != prevIndex) {
                            section.requestRerender()
                        }
                    }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/**
 * Fetch the current input value in the run scope, if set.
 *
 * You should ideally only check input values within [onInputChanged], [onInputEntered] etc. callbacks, but for edge
 * cases it can still be useful to check these in other scenarios (but treat this method with care!)
 */
fun SectionScope.getInput(id: Any = Unit): String? {
    var input: String? = null
    data.get(InputStatesKey) { input = this[id]?.text }
    return input
}

/**
 * Set the input directly from anywhere in the [RunScope].
 *
 * This should be extremely rare to do! But perhaps you need to set the text asynchronously
 * ([onInputEntered] is blocking) or inside on [onKeyPressed] callback, etc.
 *
 * However, try using [onInputChanged], [onInputEntered], etc. first. This will result in code that is easier for
 * readers to follow.
 */
fun RunScope.setInput(text: String, index: Int = text.length, id: Any = Unit) {
    data.get(InputStatesKey) {
        this[id]?.apply {
            if (this.text != text || this.index != index) {
                this.text = text
                this.index = index

                rerender()
            }
        }
    }
}

interface InputCompleter {
    /**
     * Given some [input], return a suffix that should complete it, or null if the string does not have a matching
     * completion.
     *
     * For example, for "y", you might return "es"
     */
    fun complete(input: String): String?

    val color: Color get() = Color.BRIGHT_BLACK
}

/**
 * A default [InputCompleter] that provides completions given a list of values.
 *
 * If there are multiple matches, e.g. "Colorado" and "Connecticut" for "co", the item earlier in the list will be
 * suggested as the completion.
 */
open class Completions(private vararg val values: String, private val ignoreCase: Boolean = true) : InputCompleter {
    override fun complete(input: String): String? {
        return values.firstOrNull { value ->
            value.startsWith(input, ignoreCase)
        }?.substring(input.length)
    }
}

private val CompleterKey = Section.Lifecycle.createKey<InputCompleter>()

/**
 * A function which, when called, will replace itself dynamically with some input text plus a blinking cursor.
 *
 * You can only call `input()` ONCE each render pass - if you call it twice, you'll get a runtime exception.
 *
 * You can use the `onInputChanged` and `onInputEntered` callbacks to query the value as the user types it / commits it.
 *
 * ```
 * section {
 *   text("Enter your name: "); input()
 * }.run {
 *   onInputEntered {
 *     // here, "input" is what the user typed in
 *   }
 * }
 * ```
 *
 * Occasionally, you may call `input` across multiple cases:
 *
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Usually you would do this in separate sections, but perhaps you want to cycle through questions within the same
 * section for a particular UX feel.
 *
 * You can accomplish this two ways. One, pass in an ID for each input call, or call `clearInput` on `onInputEntered`.
 *
 * Approach #1, using IDs:
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Approach #2, using `clearInput`
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input()
 *   ASK_AGE -> text("Your age? "); input()
 *   ...
 * }.run {
 *   onInputEntered {
 *      if (state == ASK_NAME) {
 *        name = input
 *        clearInput()
 *        state = ASK_AGE
 *      } else if (state == ASK_AGE) {
 *        ...
 *      }
 *   }
 * }
 * ```
 *
 * @param completer Optional logic for suggesting auto-completions based on what the user typed in. See
 *   [Completions] which is a generally useful and common implementation.
 * @param initialText Text which will be used the first time `input()` is called and ignored subsequently.
 * @param id See docs above for more details. The value of this parameter can be anything - this method simply does an
 *   equality check on it against a previous value.
 */
fun MainRenderScope.input(completer: InputCompleter? = null, initialText: String = "", id: Any = Unit, isActive: Boolean = true) {
    data.prepareInput(this, id, initialText, isActive)
    completer?.let { data[CompleterKey] = it }

    with(data.getValue(InputStatesKey)[id]!!) {
        // First, check the hard but common case. If we're the currently active input, render it with current
        // completions and cursor
        if (this.isActive) {
            val completion = try {
                completer?.complete(text)
            } catch (ex: Exception) {
                null
            } ?: ""

            // Note: Trailing space as cursor can be put AFTER last character
            val finalText = "$text$completion "

            scopedState { // Make sure color changes don't leak
                for (i in finalText.indices) {
                    if (i == text.length && completer != null && completion.isNotEmpty()) {
                        color(completer.color)
                    }
                    if (i == index && cursorState.blinkOn) {
                        invert()
                    }
                    text(finalText[i])
                    if (i == index && cursorState.blinkOn) {
                        clearInvert()
                    }
                }
            }
        }
        // Otherwise, this input is dormant, and acts like normal text
        else {
            text(text)
        }
    }
}

class OnKeyPressedScope(val key: Key)

private val KeyPressedJobKey = RunScope.Lifecycle.createKey<Job>()
private val KeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()
// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private val SystemKeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()

/**
 * Start running a job that collects keypresses and sends them to callbacks.
 *
 * This is a no-op when called after the first time.
 */
private fun ConcurrentScopedData.prepareOnKeyPressed(terminal: Terminal) {
    prepareKeyFlow(terminal)
    tryPut(
        KeyPressedJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    val scope = OnKeyPressedScope(key)
                    get(KeyPressedCallbackKey) { this.invoke(scope) }
                    get(SystemKeyPressedCallbackKey) { this.invoke(scope) }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/** A handler you can register in a `run` block to intercept keypresses */
fun RunScope.onKeyPressed(listener: OnKeyPressedScope.() -> Unit) {
    data.prepareOnKeyPressed(section.session.terminal)
    if (!data.tryPut(KeyPressedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onKeyPressed` callback at a time is supported.")
    }
}

/** A `run` block which runs until one of the specified keys is pressed by the user. */
fun Section.runUntilKeyPressed(vararg keys: Key, block: suspend RunScope.() -> Unit = {}) {
    run {
        data.prepareOnKeyPressed(this.section.session.terminal)
        data[SystemKeyPressedCallbackKey] = { if (keys.contains(key)) abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}

class OnInputActivatedScope(val id: Any, var input: String)
private val InputActivatedCallbackKey = RunScope.Lifecycle.createKey<OnInputActivatedScope.() -> Unit>()

private fun ConcurrentScopedData.withActiveInput(block: InputState.() -> Unit) {
    get(InputStatesKey) {
        values.find { it.isActive }?.block()
    }
}

fun RunScope.onInputActivated(listener: OnInputActivatedScope.() -> Unit) {
    if (!data.tryPut(InputActivatedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputActivated` callback at a time is supported.")
    } else {
        // There may already be an active input when this callback was registered.
        data.withActiveInput {
            val onInputActivatedScope = OnInputActivatedScope(id, text)
            listener(onInputActivatedScope)
            text = onInputActivatedScope.input
        }
    }
}

class OnInputDeactivatedScope(val id: Any, var input: String)
private val InputDeactivatedCallbackKey = RunScope.Lifecycle.createKey<OnInputDeactivatedScope.() -> Unit>()

fun RunScope.onInputDeactivated(listener: OnInputDeactivatedScope.() -> Unit) {
    if (!data.tryPut(InputDeactivatedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputDeactivated` callback at a time is supported.")
    }
}

class OnInputChangedScope(val id: Any, var input: String, val prevInput: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
}
private val InputChangedCallbackKey = RunScope.Lifecycle.createKey<OnInputChangedScope.() -> Unit>()

fun RunScope.onInputChanged(listener: OnInputChangedScope.() -> Unit) {
    if (!data.tryPut(InputChangedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputChanged` callback at a time is supported.")
    }
}

class OnInputEnteredScope(val id: Any, val input: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
    internal var cleared = false
    fun clearInput() { cleared = true }
}
private val InputEnteredCallbackKey = RunScope.Lifecycle.createKey<OnInputEnteredScope.() -> Unit>()

// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private object SystemInputEnteredCallbackKey : ConcurrentScopedData.Key<() -> Unit> {
    override val lifecycle = RunScope.Lifecycle
}

fun RunScope.onInputEntered(listener: OnInputEnteredScope.() -> Unit) {
    if (!data.tryPut(InputEnteredCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputEntered` callback at a time is supported.")
    }
}

fun Section.runUntilInputEntered(block: suspend RunScope.() -> Unit = {}) {
    run {
        data[SystemInputEnteredCallbackKey] = { abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}